var N=null,E="",T="t",U="u",searchIndex={};
var R=["sparse","isextended","offset","Representation of the header of an entry in an archive","linkname","typeflag","version","dev_major","dev_minor","Directory","entries","into_inner","Unwrap this archive, returning the underlying object.","result","option","unpacked","set_unpack_xattrs","Indicate whether extended file attributes (xattrs on Unix)…","set_preserve_permissions","Indicate whether extended permissions (like suid on Unix)…","set_preserve_mtime","Indicate whether access time information is preserved when…","entrytype","Returns whether this type represents a GNU long name header.","Returns whether this type represents a GNU long link header.","header","oldheader","ustarheader","gnuheader","Returns a view into this header as a byte array.","headermode","metadata","path_bytes","link_name","link_name_bytes","utf8error","Views this as a normal `Header`","set_path","username_bytes","set_username","groupname_bytes","set_groupname","device_major","set_device_major","device_minor","set_device_minor","as_header","as_header_mut","See `Header::username_bytes`","See `Header::set_username`","See `Header::groupname_bytes`","See `Header::set_groupname`","See `Header::device_major`","See `Header::set_device_major`","See `Header::device_minor`","See `Header::set_device_minor`","Returns the last modification time in Unix time format","as_bytes","as_mut_bytes","is_extended","try_from","try_into","borrow_mut","type_id","borrow","typeid","into_iter","to_owned","clone_into","formatter","GnuExtSparseHeader","GnuHeader","GnuSparseHeader","OldHeader","UstarHeader","Unpacked","EntryType","HeaderMode","PaxExtension","PaxExtensions"];

searchIndex["tar"]={"doc":"A library for reading and writing TAR archives","i":[[3,"Archive","tar","A top-level representation of an archive file.",N,N],[3,"Entries",E,"An iterator over the entries of an archive.",N,N],[3,"Builder",E,"A structure for building archives",N,N],[3,"Entry",E,"A read-only view into an entry of an archive.",N,N],[3,R[70],E,"Representation of the entry found to represent extended…",N,N],[12,R[0],E,E,0,N],[12,R[1],E,E,0,N],[12,"padding",E,E,0,N],[3,R[71],E,R[3],N,N],[12,"name",E,E,1,N],[12,"mode",E,E,1,N],[12,"uid",E,E,1,N],[12,"gid",E,E,1,N],[12,"size",E,E,1,N],[12,"mtime",E,E,1,N],[12,"cksum",E,E,1,N],[12,R[5],E,E,1,N],[12,R[4],E,E,1,N],[12,"magic",E,E,1,N],[12,R[6],E,E,1,N],[12,"uname",E,E,1,N],[12,"gname",E,E,1,N],[12,R[7],E,E,1,N],[12,R[8],E,E,1,N],[12,"atime",E,E,1,N],[12,"ctime",E,E,1,N],[12,R[2],E,E,1,N],[12,"longnames",E,E,1,N],[12,"unused",E,E,1,N],[12,R[0],E,E,1,N],[12,R[1],E,E,1,N],[12,"realsize",E,E,1,N],[12,"pad",E,E,1,N],[3,R[72],E,"Description of the header of a spare entry.",N,N],[12,R[2],E,E,2,N],[12,"numbytes",E,E,2,N],[3,"Header",E,R[3],N,N],[3,R[73],E,R[3],N,N],[12,"name",E,E,3,N],[12,"mode",E,E,3,N],[12,"uid",E,E,3,N],[12,"gid",E,E,3,N],[12,"size",E,E,3,N],[12,"mtime",E,E,3,N],[12,"cksum",E,E,3,N],[12,"linkflag",E,E,3,N],[12,R[4],E,E,3,N],[12,"pad",E,E,3,N],[3,R[74],E,R[3],N,N],[12,"name",E,E,4,N],[12,"mode",E,E,4,N],[12,"uid",E,E,4,N],[12,"gid",E,E,4,N],[12,"size",E,E,4,N],[12,"mtime",E,E,4,N],[12,"cksum",E,E,4,N],[12,R[5],E,E,4,N],[12,R[4],E,E,4,N],[12,"magic",E,E,4,N],[12,R[6],E,E,4,N],[12,"uname",E,E,4,N],[12,"gname",E,E,4,N],[12,R[7],E,E,4,N],[12,R[8],E,E,4,N],[12,"prefix",E,E,4,N],[12,"pad",E,E,4,N],[3,R[78],E,"A key/value pair corresponding to a pax extension.",N,N],[3,R[79],E,"An iterator over the pax extensions in an archive entry.",N,N],[4,R[75],E,"When unpacking items the unpacked thing is returned to…",N,N],[13,"File",E,"A file was unpacked.",5,N],[4,R[76],E,"Indicate for the type of file described by a header.",N,N],[13,"Regular",E,"Regular file",6,N],[13,"Link",E,"Hard link",6,N],[13,"Symlink",E,"Symbolic link",6,N],[13,"Char",E,"Character device",6,N],[13,"Block",E,"Block device",6,N],[13,R[9],E,R[9],6,N],[13,"Fifo",E,"Named pipe (fifo)",6,N],[13,"Continuous",E,"Implementation-defined 'high-performance' type, treated as…",6,N],[13,"GNULongName",E,"GNU extension - long file name",6,N],[13,"GNULongLink",E,"GNU extension - long link name (link target)",6,N],[13,"GNUSparse",E,"GNU extension - sparse file",6,N],[13,"XGlobalHeader",E,"Global extended header",6,N],[13,"XHeader",E,"Extended Header",6,N],[4,R[77],E,"Declares the information that should be included when…",N,N],[13,"Complete",E,"All supported metadata, including mod/access times and…",7,N],[13,"Deterministic",E,"Only metadata that is directly relevant to the identity of…",7,N],[11,"new",E,"Create a new archive with the underlying object as the…",8,[[["r"]],["archive"]]],[11,R[11],E,R[12],8,[[],["r"]]],[11,R[10],E,"Construct an iterator over the entries in this archive.",8,[[["self"]],[[R[13],[R[10]]],[R[10]]]]],[11,"unpack",E,"Unpacks the contents tarball into the specified `dst`.",8,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,R[16],E,R[17],8,[[["self"],["bool"]]]],[11,R[18],E,R[19],8,[[["self"],["bool"]]]],[11,R[20],E,R[21],8,[[["self"],["bool"]]]],[11,"set_ignore_zeros",E,"Ignore zeroed headers, which would otherwise indicate to…",8,[[["self"],["bool"]]]],[11,"raw",E,"Indicates whether this iterator will return raw entries or…",9,[[["bool"]],[R[10]]]],[11,"new",E,"Create a new archive builder with the underlying object as…",10,[[["w"]],["builder"]]],[11,"mode",E,"Changes the HeaderMode that will be used when reading fs…",10,[[["self"],[R[30]]]]],[11,"follow_symlinks",E,"Follow symlinks, archiving the contents of the file they…",10,[[["self"],["bool"]]]],[11,"get_ref",E,"Gets shared reference to the underlying object.",10,[[["self"]],["w"]]],[11,"get_mut",E,"Gets mutable reference to the underlying object.",10,[[["self"]],["w"]]],[11,R[11],E,R[12],10,[[],[R[13]]]],[11,"append",E,"Adds a new entry to this archive.",10,[[["self"],["read"],[R[25]]],[R[13]]]],[11,"append_data",E,"Adds a new entry to this archive with the specified path.",10,[[["self"],["read"],[R[25]],["asref",["path"]],["path"]],[R[13]]]],[11,"append_path",E,"Adds a file on the local filesystem to this archive.",10,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,"append_path_with_name",E,"Adds a file on the local filesystem to this archive under…",10,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,"append_file",E,"Adds a file to this archive with the given path as the…",10,[[["self"],["file"],["asref",["path"]],["path"]],[R[13]]]],[11,"append_dir",E,"Adds a directory to this archive with the given path as…",10,[[["self"],["q"],["p"]],[R[13]]]],[11,"append_dir_all",E,"Adds a directory and all of its contents (recursively) to…",10,[[["self"],["q"],["p"]],[R[13]]]],[11,"finish",E,"Finish writing this archive, emitting the termination…",10,[[["self"]],[R[13]]]],[11,"path",E,"Returns the path name for this entry.",11,[[["self"]],[[R[13],["cow"]],["cow",["path"]]]]],[11,R[32],E,"Returns the raw bytes listed for this entry.",11,[[["self"]],["cow"]]],[11,R[33],E,"Returns the link name for this entry, if any is found.",11,[[["self"]],[[R[13],[R[14]]],[R[14],["cow"]]]]],[11,R[34],E,"Returns the link name for this entry, in bytes, if listed.",11,[[["self"]],[[R[14],["cow"]],["cow"]]]],[11,"pax_extensions",E,"Returns an iterator over the pax extensions contained in…",11,[[["self"]],[[R[14],["paxextensions"]],[R[13],[R[14]]]]]],[11,R[25],E,"Returns access to the header of this entry in the archive.",11,[[["self"]],[R[25]]]],[11,"raw_header_position",E,"Returns the starting position, in bytes, of the header of…",11,[[["self"]],["u64"]]],[11,"raw_file_position",E,"Returns the starting position, in bytes, of the file of…",11,[[["self"]],["u64"]]],[11,"unpack",E,"Writes this file to the specified location.",11,[[["self"],["asref",["path"]],["path"]],[[R[13],[R[15]]],[R[15]]]]],[11,"unpack_in",E,"Extracts this file under the specified path, avoiding…",11,[[["self"],["asref",["path"]],["path"]],[["bool"],[R[13],["bool"]]]]],[11,R[16],E,R[17],11,[[["self"],["bool"]]]],[11,R[18],E,R[19],11,[[["self"],["bool"]]]],[11,R[20],E,R[21],11,[[["self"],["bool"]]]],[11,"new",E,"Creates a new entry type from a raw byte.",6,[[["u8"]],[R[22]]]],[11,"as_byte",E,"Returns the raw underlying byte that this entry type…",6,[[["self"]],["u8"]]],[11,"file",E,"Creates a new entry type representing a regular file.",6,[[],[R[22]]]],[11,"hard_link",E,"Creates a new entry type representing a hard link.",6,[[],[R[22]]]],[11,"symlink",E,"Creates a new entry type representing a symlink.",6,[[],[R[22]]]],[11,"character_special",E,"Creates a new entry type representing a character special…",6,[[],[R[22]]]],[11,"block_special",E,"Creates a new entry type representing a block special…",6,[[],[R[22]]]],[11,"dir",E,"Creates a new entry type representing a directory.",6,[[],[R[22]]]],[11,"fifo",E,"Creates a new entry type representing a FIFO.",6,[[],[R[22]]]],[11,"contiguous",E,"Creates a new entry type representing a contiguous file.",6,[[],[R[22]]]],[11,"is_file",E,"Returns whether this type represents a regular file.",6,[[["self"]],["bool"]]],[11,"is_hard_link",E,"Returns whether this type represents a hard link.",6,[[["self"]],["bool"]]],[11,"is_symlink",E,"Returns whether this type represents a symlink.",6,[[["self"]],["bool"]]],[11,"is_character_special",E,"Returns whether this type represents a character special…",6,[[["self"]],["bool"]]],[11,"is_block_special",E,"Returns whether this type represents a block special device.",6,[[["self"]],["bool"]]],[11,"is_dir",E,"Returns whether this type represents a directory.",6,[[["self"]],["bool"]]],[11,"is_fifo",E,"Returns whether this type represents a FIFO.",6,[[["self"]],["bool"]]],[11,"is_contiguous",E,"Returns whether this type represents a contiguous file.",6,[[["self"]],["bool"]]],[11,"is_gnu_longname",E,R[23],6,[[["self"]],["bool"]]],[11,"is_gnu_sparse",E,"Returns whether this type represents a GNU sparse header.",6,[[["self"]],["bool"]]],[11,"is_gnu_longlink",E,R[24],6,[[["self"]],["bool"]]],[11,"is_pax_global_extensions",E,R[23],6,[[["self"]],["bool"]]],[11,"is_pax_local_extensions",E,R[24],6,[[["self"]],["bool"]]],[11,"new_gnu",E,"Creates a new blank GNU header.",12,[[],[R[25]]]],[11,"new_ustar",E,"Creates a new blank UStar header.",12,[[],[R[25]]]],[11,"new_old",E,"Creates a new blank old header.",12,[[],[R[25]]]],[11,"as_old",E,"View this archive header as a raw \"old\" archive header.",12,[[["self"]],[R[26]]]],[11,"as_old_mut",E,"Same as `as_old`, but the mutable version.",12,[[["self"]],[R[26]]]],[11,"as_ustar",E,"View this archive header as a raw UStar archive header.",12,[[["self"]],[[R[27]],[R[14],[R[27]]]]]],[11,"as_ustar_mut",E,"Same as `as_ustar_mut`, but the mutable version.",12,[[["self"]],[[R[27]],[R[14],[R[27]]]]]],[11,"as_gnu",E,"View this archive header as a raw GNU archive header.",12,[[["self"]],[[R[28]],[R[14],[R[28]]]]]],[11,"as_gnu_mut",E,"Same as `as_gnu`, but the mutable version.",12,[[["self"]],[[R[14],[R[28]]],[R[28]]]]],[11,"from_byte_slice",E,"Treats the given byte slice as a header.",12,[[],[R[25]]]],[11,R[57],E,R[29],12,[[["self"]]]],[11,R[58],E,R[29],12,[[["self"]]]],[11,"set_metadata",E,"Blanket sets the metadata in this header from the metadata…",12,[[["self"],[R[31]]]]],[11,"set_metadata_in_mode",E,"Sets only the metadata relevant to the given HeaderMode in…",12,[[["self"],[R[30]],[R[31]]]]],[11,"entry_size",E,"Returns the size of entry's data this header represents.",12,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"size",E,"Returns the file size this header represents.",12,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_size",E,"Encodes the `size` argument into the size field of this…",12,[[["self"],["u64"]]]],[11,"path",E,"Returns the raw path name stored in this header.",12,[[["self"]],[[R[13],["cow"]],["cow",["path"]]]]],[11,R[32],E,"Returns the pathname stored in this header as a byte array.",12,[[["self"]],["cow"]]],[11,R[37],E,"Sets the path name for this header.",12,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,R[33],E,"Returns the link name stored in this header, if any is…",12,[[["self"]],[[R[13],[R[14]]],[R[14],["cow"]]]]],[11,R[34],E,"Returns the link name stored in this header as a byte…",12,[[["self"]],[[R[14],["cow"]],["cow"]]]],[11,"set_link_name",E,"Sets the link name for this header.",12,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,"mode",E,"Returns the mode bits for this file",12,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,"set_mode",E,"Encodes the `mode` provided into this header.",12,[[["self"],["u32"]]]],[11,"uid",E,"Returns the value of the owner's user ID field",12,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_uid",E,"Encodes the `uid` provided into this header.",12,[[["self"],["u64"]]]],[11,"gid",E,"Returns the value of the group's user ID field",12,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_gid",E,"Encodes the `gid` provided into this header.",12,[[["self"],["u64"]]]],[11,"mtime",E,R[56],12,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_mtime",E,"Encodes the `mtime` provided into this header.",12,[[["self"],["u64"]]]],[11,"username",E,"Return the user name of the owner of this file.",12,[[["self"]],[[R[14],["str"]],[R[35]],[R[13],[R[14],R[35]]]]]],[11,R[38],E,"Returns the user name of the owner of this file, if present.",12,[[["self"]],[R[14]]]],[11,R[39],E,"Sets the username inside this header.",12,[[["self"],["str"]],[R[13]]]],[11,"groupname",E,"Return the group name of the owner of this file.",12,[[["self"]],[[R[14],["str"]],[R[35]],[R[13],[R[14],R[35]]]]]],[11,R[40],E,"Returns the group name of the owner of this file, if…",12,[[["self"]],[R[14]]]],[11,R[41],E,"Sets the group name inside this header.",12,[[["self"],["str"]],[R[13]]]],[11,R[42],E,"Returns the device major number, if present.",12,[[["self"]],[[R[14],["u32"]],[R[13],[R[14]]]]]],[11,R[43],E,"Encodes the value `major` into the dev_major field of this…",12,[[["self"],["u32"]],[R[13]]]],[11,R[44],E,"Returns the device minor number, if present.",12,[[["self"]],[[R[14],["u32"]],[R[13],[R[14]]]]]],[11,R[45],E,"Encodes the value `minor` into the dev_minor field of this…",12,[[["self"],["u32"]],[R[13]]]],[11,"entry_type",E,"Returns the type of file described by this header.",12,[[["self"]],[R[22]]]],[11,"set_entry_type",E,"Sets the type of file that will be described by this header.",12,[[["self"],[R[22]]]]],[11,"cksum",E,"Returns the checksum field of this header.",12,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,"set_cksum",E,"Sets the checksum field of this header based on the…",12,[[["self"]]]],[11,R[46],E,R[36],3,[[["self"]],[R[25]]]],[11,R[47],E,R[36],3,[[["self"]],[R[25]]]],[11,R[32],E,"See `Header::path_bytes`",4,[[["self"]],["cow"]]],[11,R[37],E,"See `Header::set_path`",4,[[["self"],["asref",["path"]],["path"]],[R[13]]]],[11,R[38],E,R[48],4,[[["self"]]]],[11,R[39],E,R[49],4,[[["self"],["str"]],[R[13]]]],[11,R[40],E,R[50],4,[[["self"]]]],[11,R[41],E,R[51],4,[[["self"],["str"]],[R[13]]]],[11,R[42],E,R[52],4,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[43],E,R[53],4,[[["self"],["u32"]]]],[11,R[44],E,R[54],4,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[45],E,R[55],4,[[["self"],["u32"]]]],[11,R[46],E,R[36],4,[[["self"]],[R[25]]]],[11,R[47],E,R[36],4,[[["self"]],[R[25]]]],[11,R[38],E,R[48],1,[[["self"]]]],[11,R[39],E,R[49],1,[[["self"],["str"]],[R[13]]]],[11,R[40],E,R[50],1,[[["self"]]]],[11,R[41],E,R[51],1,[[["self"],["str"]],[R[13]]]],[11,R[42],E,R[52],1,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[43],E,R[53],1,[[["self"],["u32"]]]],[11,R[44],E,R[54],1,[[["self"]],[[R[13],["u32"]],["u32"]]]],[11,R[45],E,R[55],1,[[["self"],["u32"]]]],[11,"atime",E,R[56],1,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_atime",E,"Encodes the `atime` provided into this header.",1,[[["self"],["u64"]]]],[11,"ctime",E,R[56],1,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"set_ctime",E,"Encodes the `ctime` provided into this header.",1,[[["self"],["u64"]]]],[11,"real_size",E,"Returns the \"real size\" of the file this header represents.",1,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,R[59],E,"Indicates whether this header will be followed by…",1,[[["self"]],["bool"]]],[11,R[46],E,R[36],1,[[["self"]],[R[25]]]],[11,R[47],E,R[36],1,[[["self"]],[R[25]]]],[11,"is_empty",E,"Returns true if block is empty",2,[[["self"]],["bool"]]],[11,R[2],E,"Offset of the block from the start of the file",2,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"length",E,"Length of the block",2,[[["self"]],[[R[13],["u64"]],["u64"]]]],[11,"new",E,"Crates a new zero'd out sparse header entry.",0,[[],["gnuextsparseheader"]]],[11,R[57],E,R[29],0,[[["self"]]]],[11,R[58],E,R[29],0,[[["self"]]]],[11,R[0],E,"Returns a slice of the underlying sparse headers.",0,[[["self"]]]],[11,R[59],E,"Indicates if another sparse header should be following…",0,[[["self"]],["bool"]]],[11,"key",E,"Returns the key for this key/value pair parsed as a string.",13,[[["self"]],[[R[13],["str",R[35]]],["str"],[R[35]]]]],[11,"key_bytes",E,"Returns the underlying raw bytes for the key of this…",13,[[["self"]]]],[11,"value",E,"Returns the value for this key/value pair parsed as a…",13,[[["self"]],[[R[13],["str",R[35]]],["str"],[R[35]]]]],[11,"value_bytes",E,"Returns the underlying raw bytes for this value of this…",13,[[["self"]]]],[11,"into",E,E,8,[[],[U]]],[11,"from",E,E,8,[[[T]],[T]]],[11,R[60],E,E,8,[[[U]],[R[13]]]],[11,R[61],E,E,8,[[],[R[13]]]],[11,R[62],E,E,8,[[["self"]],[T]]],[11,R[64],E,E,8,[[["self"]],[T]]],[11,R[63],E,E,8,[[["self"]],[R[65]]]],[11,"into",E,E,9,[[],[U]]],[11,R[66],E,E,9,[[],["i"]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[60],E,E,9,[[[U]],[R[13]]]],[11,R[61],E,E,9,[[],[R[13]]]],[11,R[62],E,E,9,[[["self"]],[T]]],[11,R[64],E,E,9,[[["self"]],[T]]],[11,R[63],E,E,9,[[["self"]],[R[65]]]],[11,"into",E,E,10,[[],[U]]],[11,"from",E,E,10,[[[T]],[T]]],[11,R[60],E,E,10,[[[U]],[R[13]]]],[11,R[61],E,E,10,[[],[R[13]]]],[11,R[62],E,E,10,[[["self"]],[T]]],[11,R[64],E,E,10,[[["self"]],[T]]],[11,R[63],E,E,10,[[["self"]],[R[65]]]],[11,"into",E,E,11,[[],[U]]],[11,"from",E,E,11,[[[T]],[T]]],[11,R[60],E,E,11,[[[U]],[R[13]]]],[11,R[61],E,E,11,[[],[R[13]]]],[11,R[62],E,E,11,[[["self"]],[T]]],[11,R[64],E,E,11,[[["self"]],[T]]],[11,R[63],E,E,11,[[["self"]],[R[65]]]],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[60],E,E,0,[[[U]],[R[13]]]],[11,R[61],E,E,0,[[],[R[13]]]],[11,R[62],E,E,0,[[["self"]],[T]]],[11,R[64],E,E,0,[[["self"]],[T]]],[11,R[63],E,E,0,[[["self"]],[R[65]]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[60],E,E,1,[[[U]],[R[13]]]],[11,R[61],E,E,1,[[],[R[13]]]],[11,R[62],E,E,1,[[["self"]],[T]]],[11,R[64],E,E,1,[[["self"]],[T]]],[11,R[63],E,E,1,[[["self"]],[R[65]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[60],E,E,2,[[[U]],[R[13]]]],[11,R[61],E,E,2,[[],[R[13]]]],[11,R[62],E,E,2,[[["self"]],[T]]],[11,R[64],E,E,2,[[["self"]],[T]]],[11,R[63],E,E,2,[[["self"]],[R[65]]]],[11,R[67],E,E,12,[[["self"]],[T]]],[11,R[68],E,E,12,[[["self"],[T]]]],[11,"into",E,E,12,[[],[U]]],[11,"from",E,E,12,[[[T]],[T]]],[11,R[60],E,E,12,[[[U]],[R[13]]]],[11,R[61],E,E,12,[[],[R[13]]]],[11,R[62],E,E,12,[[["self"]],[T]]],[11,R[64],E,E,12,[[["self"]],[T]]],[11,R[63],E,E,12,[[["self"]],[R[65]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[60],E,E,3,[[[U]],[R[13]]]],[11,R[61],E,E,3,[[],[R[13]]]],[11,R[62],E,E,3,[[["self"]],[T]]],[11,R[64],E,E,3,[[["self"]],[T]]],[11,R[63],E,E,3,[[["self"]],[R[65]]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[60],E,E,4,[[[U]],[R[13]]]],[11,R[61],E,E,4,[[],[R[13]]]],[11,R[62],E,E,4,[[["self"]],[T]]],[11,R[64],E,E,4,[[["self"]],[T]]],[11,R[63],E,E,4,[[["self"]],[R[65]]]],[11,"into",E,E,13,[[],[U]]],[11,"from",E,E,13,[[[T]],[T]]],[11,R[60],E,E,13,[[[U]],[R[13]]]],[11,R[61],E,E,13,[[],[R[13]]]],[11,R[62],E,E,13,[[["self"]],[T]]],[11,R[64],E,E,13,[[["self"]],[T]]],[11,R[63],E,E,13,[[["self"]],[R[65]]]],[11,"into",E,E,14,[[],[U]]],[11,R[66],E,E,14,[[],["i"]]],[11,"from",E,E,14,[[[T]],[T]]],[11,R[60],E,E,14,[[[U]],[R[13]]]],[11,R[61],E,E,14,[[],[R[13]]]],[11,R[62],E,E,14,[[["self"]],[T]]],[11,R[64],E,E,14,[[["self"]],[T]]],[11,R[63],E,E,14,[[["self"]],[R[65]]]],[11,"into",E,E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[60],E,E,5,[[[U]],[R[13]]]],[11,R[61],E,E,5,[[],[R[13]]]],[11,R[62],E,E,5,[[["self"]],[T]]],[11,R[64],E,E,5,[[["self"]],[T]]],[11,R[63],E,E,5,[[["self"]],[R[65]]]],[11,R[67],E,E,6,[[["self"]],[T]]],[11,R[68],E,E,6,[[["self"],[T]]]],[11,"into",E,E,6,[[],[U]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[60],E,E,6,[[[U]],[R[13]]]],[11,R[61],E,E,6,[[],[R[13]]]],[11,R[62],E,E,6,[[["self"]],[T]]],[11,R[64],E,E,6,[[["self"]],[T]]],[11,R[63],E,E,6,[[["self"]],[R[65]]]],[11,R[67],E,E,7,[[["self"]],[T]]],[11,R[68],E,E,7,[[["self"],[T]]]],[11,"into",E,E,7,[[],[U]]],[11,"from",E,E,7,[[[T]],[T]]],[11,R[60],E,E,7,[[[U]],[R[13]]]],[11,R[61],E,E,7,[[],[R[13]]]],[11,R[62],E,E,7,[[["self"]],[T]]],[11,R[64],E,E,7,[[["self"]],[T]]],[11,R[63],E,E,7,[[["self"]],[R[65]]]],[11,"drop",E,E,10,[[["self"]]]],[11,"default",E,E,0,[[],["self"]]],[11,"clone",E,E,6,[[["self"]],[R[22]]]],[11,"clone",E,E,7,[[["self"]],[R[30]]]],[11,"clone",E,E,12,[[["self"]],[R[25]]]],[11,"eq",E,E,6,[[["self"],[R[22]]],["bool"]]],[11,"ne",E,E,6,[[["self"],[R[22]]],["bool"]]],[11,"eq",E,E,7,[[["self"],[R[30]]],["bool"]]],[11,"next",E,E,9,[[["self"]],[[R[13],["entry"]],[R[14],[R[13]]]]]],[11,"next",E,E,14,[[["self"]],[[R[14],[R[13]]],[R[13],["paxextension"]]]]],[11,"fmt",E,E,5,[[["self"],[R[69]]],[R[13]]]],[11,"fmt",E,E,6,[[["self"],[R[69]]],[R[13]]]],[11,"fmt",E,E,7,[[["self"],[R[69]]],[R[13]]]],[11,"fmt",E,E,12,[[["self"],[R[69]]],[R[13]]]],[11,"fmt",E,E,3,[[["self"],[R[69]]],[R[13]]]],[11,"fmt",E,E,4,[[["self"],[R[69]]],[R[13]]]],[11,"fmt",E,E,1,[[["self"],[R[69]]],[R[13]]]],[11,"fmt",E,E,2,[[["self"],[R[69]]],[R[13]]]],[11,"read",E,E,11,[[["self"]],[[R[13],["usize"]],["usize"]]]]],"p":[[3,R[70]],[3,R[71]],[3,R[72]],[3,R[73]],[3,R[74]],[4,R[75]],[4,R[76]],[4,R[77]],[3,"Archive"],[3,"Entries"],[3,"Builder"],[3,"Entry"],[3,"Header"],[3,R[78]],[3,R[79]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);